# [20] 읽을 수 있는 패스워드

A : “저는 영업부의 팻 존슨이에요. 패스워드를 잊어버렸어요. 알려주세요”

B : “여기 있습니다.”

(한참 후)

:

B : “영업부 팻 존슨이 비밀번호를 알려달라 떼를 써서 그에게 그냥 알려줬어”

C : “뭐래. 영업부 팻 존슨은 여자야. 사기꾼같은데?”

## 목표 : 패스워드를 복구하거나 재설정하기

- 어떤 어플리케이션에서든 패스워드가 있고 사용자가 패스워드를 잃어버렸다면, 패스워드를 재설정할 수 있게 해야 한다

## 안티패턴 : 패스워드를 평문으로 저장하기

- 패스워드를 평문으로 담은 이메일은 데이터베이스 설계와 관련된 심각한 보안 결함이다
- 인증받지 않은 사람이 어플리케이션 접근 권한을 얻을 수 있는 위험을 초래한다

## 패스워드 저장

- 패스워드는 보통 accounts 테이블에 문자열 속성 컬럼으로 저장된다
- 패스워드를 평문으로 저장하거나 평문 상태로 네트워크를 통해 전달하는 것은 안전하지 않다
- 공격자가 SQL문을 가로채서 읽을 수 있다면, 패스워드가 그대로 노출된다
    - 패스워드를 변경하기 위한 SQL문이나,
    사용자의 입력이 저장된 패스워드와 일치하는지를 확인하는 SQL문도 마찬가지
- 해커는 이와같은 방식으로 패스워드를 가로챌 수 있다
    - 클라이언트 어플리케이션에서 데이터베이스 서버로 전송되는 네트워크 패킷을 가로챈다
    - 공격자가 데이터베이스 서버 접근 권한을 획득했다면, 데이터베이스 서버에서 실행된 SQL문의 기록이 포함된 로그 파일에도 접근할 수 있다
    - 서버나 백업 미디어에 저장되어 있는 데이터베이스 백업 파일로부터 데이터를 읽을 수 있다
    

## 패스워드 인증

- 어플리케이션은 사용자의 입력과 데이터베이스에 저장된 패스워드 문자열을 비교한다
- 패스워드가 평문으로 저장되어있기 때문에 이 비교도 평문으로 수행된다
- 따라서, 사용자 입력 문자열을 SQL 쿼리에 평문으로 삽입하면 공격자에게 패스워드가 그대로 노출된다
- 두 개의 다른 조건을 한 덩어리로 만들지 마라
    - 인증 쿼리에서 account_id와 password 컬럼에 대한 조건을 모두 WHERE 절에 놓은 경우가 많다
        
        ```bash
        SELECT * FROM accounts WHERE account_name = 'bil' AND password = '1234';
        ```
        
    - 이 방식은 계정이 존재하지 않거나, 사용자가 정확한 패스워드를 제시하지 못한 경우 같은 결과를 리턴한다
    - 어플리케이션에서는 이 두가지 인증 실패 원인을 구분할 수 없다
    - 두 경우를 다르게 처리할 수 있도록 쿼리를 작성하는 것이 더 좋다

## 이메일로 패스워드 보내기

- 패스워드가 데이터베이스에 평문으로 저장되었기 때문에, 어플리케이션에서 패스워드를 검색하는 것도 간단하다
- 사용중인 웹사이트에서 패스워드를 알려주는 메일을 받아본 적이 있다면, 이는 보안에 심각한 위험상태임을 알 수 있다
- 이메일을 여러가지 방법으로 가로채거나, 로깅하거나, 저장할 수 있다

## 안티패턴 인식 방법

- 패스워드를 복구하고 사용자에게 보내는 어플리케이션 : 패스워드를 평문으로 저장하거나 역변환할수있는 암호화기법을 사요하고 있다는 것이다
- 어플리케이션에서 적법한 목적으로 패스워드를 읽을 수 있다면, 불법적으로 패스워드를 읽는 것도 가능한 것이다

## 안티패턴 사용이 합당한 경우

- 어플리케이션에서 패스워드를 이용하여 다른 서드파티 서비스에 접근해야 할 수 있다
    - 어플리케이션이 곧 클라이언트가 되는 경우이다
    - 이런 경우에는, 패스워드를 읽을 수 있는 형식으로 저장해야 한다
    - 데이터베이스에 평문으로 저장하기 보다는, 어플리케이션에서 풀 수 있는 암호화 기법을 사용하는 것이 더 좋다
- identification과 authentication을 구분할 수 있다
    - identification은 자신이 누구라고 주장할 때 그 사람이 맞는지를 증명하는 것이다
        - 패스워드는 이 중에 사용되는 가장 흔한 방법이다
    - identification이 꼭 필요한 것이 아니다
        - 모든 소프트웨어 어플리케이션에서 공격 위험에 처해있는 것도 아니고, 모든 어플리케이션이 보호해야 할 민감한 정보를 가지고 있는 것도 아니다
        - 인트라넷 어플리케이션은 정직하고 협조적이라고 알려진 몇명에서만 사용할 수 있다
        - 이런 경우, 인증 매커니즘이면 충분하다
        (하지만, 이런 가벼운 인트라넷 어플리케이션을 회사 방화벽 밖에서도 사용 가능하게 바꾼다면..?)

## 해법: 패스워드의 소금 친 해시 값을 저장한다

- 해시 함수 이해하기
    - 일방향 해시 함수를 사용해 패스워드를 encoding한다
    - 해시 함수는 입력 문자열을 해시라 불리는 알아볼 수 없는 문자열로 변환한다
        - 해시 함수가 리턴하는 문자열은 항상 길이가 같기 때문에, 문자열 길이조차 알 수 없게 된다
    - 해시는 역으로는 구할 수 없다
        - 해시 값으로는 원래의 입력된 값을 구할 수 없다
        - 해시 알고리즘은 입력에 대한 일부 정보를 잃어버리도록 설계되었기 때문이다
    - 예전에는 SHA-1이 인기있었으나, 160비트 해시 알고리즘은 암호학적으로 충분히 강력하지 않다
        - 미국 국립 표준국은 SHA-256, SHA-384, SHA-512같은 좀 더 강력한 형태의 알고리즘 사용을 권장하고 있다
        - (MD5 역시 인기가 있었으나, 암호학적으로 약하다는 것이 증명되었다)
- SQL에서 해시 사용하기
    - accounts 테이블을 다시 정의한다
        
        ```bash
        CREATE TABLE accounts(
        	account_id    SERIAL PRIMARY KEY,
        	account_name  VARCHAR(20),
        	email         VARCHAR(100), NOT NULL,
        	password_hash CHAR(64) NOT NULL
        )
        ```
        
    - 해시 함수는 SQL 표준에 포함되어 있지 않으므로, 해시 함수를 지원하는 데이터베이스 확장 기능을 사용한다
    - MySQL 6.0.5 에서는 디폴트로 256비트 해시 값을 리턴하는 SHA2 함수를 사용할 수 있다
        
        ```bash
        INSERT INTO accounts(account_id, account_name, email, password_hash)
        VALUES(123, 'billkarwin', 'bill@example.com', SHA2('xyzzy'));
        ```
        
    - 사용자가 입력에 동일한 해시 함수를 적용해 데이터베이스에 저장된 값과 비교하면, 사용자가 입력한 패스워드가 맞는지 확인할 수 있다
        
        ```bash
        SELECT CASE WHEN password_hash = SHA2('syzzy') THEN 1 ELSE 0 END AS password_matches
        FROM accounts
        WHERE account_id=123;
        ```
        
- 해시에 소금 추가하기
    - 패스워드 대신 해시 값을 저장했어도 공격자가 데이터베이스에 접근했다면, 공격자는 여전히 무작정 입력하고 에러를 얻는 방법으로 패스워드를 알아내려 할 수 있다
    - 공격자가, 사용될 것같은 패스워드의 해시 값을 담은 사전을 미리 준비해서, 데이터베이스에 저장된 해시 값과 비교할 수 있다
        
        ```bash
        CREATE TABLE dictionary_hashes (
        	password      VARCHAR(100),
        	password_hash CHAR(64)
        );
        ```
        
    - 이런 사전 공격을 물리치는 방법 중 하나는 패스워드를 부호화할 때 소금을 추가하는 것이다
    - 이것은, 해시값을 구하기 전에 사용자의 패스워드에 덧붙이는 무의미한 바이트열이다
    - 사용자가 사전에 있는 단어를 패스워드로 사용한다 해도, 소금을 친 패스워드를 이용해 만든 해시 값은 공격자의 해시 데이터베이스에 있는 값과 매치되지 않는다
    - 예를 들어 패스워드가 password라면, 이 단어의 해시 값과 단어 뒤에 임의의 바이트를 덧붙여 만든 해시 값은 서로 다르다
        - SHA2(’passrod’) ≠ SHA2(’password-0Xt!3f’)
- SQL에서 패스워드 숨기기
    - 웹 어플리케이션과 데이터베이스 사이
        - SQL 문장에 패스워드가 여전히 평문으로 노출되고 있다면, 공격자가 네트워크 패킷을 가로채거나 SQL 쿼리가 기록된 로그 파일이 잘못된 손에 전달된다면 공격자가 패스워드를 읽을 수 있다
        - SQL 쿼리에 패스워드를 평문으로 넣지 않고 대신 어플리케이션 코드에서 해시 값을 계산해 SQL 쿼리에서 이 해시 값을 사용하면, 이런 노출을 피할 수 있다
        - 어플리케이션에서 해시 값을 계산할 때에도 소금을 쳐서 보안을 더 강화시킬 수 있다
    - 사용자 브라우저와 웹어플리케이션 사이
        - 사용자가 로그인 폼을 채워 제출할 때, 평문 상태의 패스워드를 서버로 보낸다
        - 폼 데이터를 보내기 전에, 브라우저에서 해시 값을 계산하게 하면 패스워드를 보호할 수 있을 것 같지만, 그렇게 하기는 어렵다
        - 적절한 해시 값을 구하기 위해서는 해당 패스워드와 연관된 소금 값을 알아야 하기 때문이다
        - 브라우저에서 어플리케이션 서버로 패스워드를 보낼 때는 항상 HTTPS같은 보안 프로토콜을 사용하는 것이 좋다
- 패스워드 복구가 아닌 패스워드 재설정 사용하기
    - 사용자가 패스워드를 잊어버렸을 때 어떻게 해야 할까?
    - 패스워드 대신 해시 값이 저장되므로 패스워드를 복구해줄 수는 없다
    - 따라서 패스워드를 재설정하는 방식을 선택한다
    1. 어플리케이션에서 생성한 임시 패스워드를 보낸다
        - 좀 더 안전하게 하려면, 짧은 시간이 지난 후에 임시 패스워드를 만료시킨다
        - 따라서 이메일을 누군가 가로채더라도 권한이 없는 사람의 접근을 허용할 가능성이 줄어든다
        - 임시 패스워드로 로그인한 사용자는 패스워드를 변경하도록 강제해야 한다
    2. 요청을 데이터베이스 테이블에 기록하고 아이디로 유일한 토큰을 할당한다
        
        ```sql
        CREATE TABLE password_reset_requests (
        	token       CHAR932) PRIMARY KEY,
        	account_id  BIGINT UNSIGNED NOT NULL,
        	expiration  TIMESTAMP NOT NULL,
        	FOREIGN KEY (account_id) REFERENCES accounts(account_id)
        );
        
        SET @token = MD5('billkarwin' || CURRENT_TIMESTAMP || RAND());
        
        INSERT INTO password_reset_requests(token, account_id, expriation)
        VALUES(@token, 123, CURRENT_TIMESTAMP + INTERVAL 1 HOUR);
        ```
        
        - 그런 다음, 토큰을 이메일로 보낸다
        - 어플리케이션이 reset_password 페이지 요청을 받으면, token 파라미터 값이 password_reset_requests 테이블에 있느 행의 값과 일치해야 하며, 만료일도 지나지 않아야 한다
        - 그리고 이 토큰에 해당하는 계정 하나에 대해서만 패스워드 재설정 기능을 활성화 한다
    

> 당신이 패스워드를 읽을 수 있다면, 해커도 읽을 수 있다
>