# [16] 임의의 선택

- 무작위로 데이터를 선택하는 쿼리의 성능을 어떻게 개선시킬 수 있을까?
- ex) 무작위로 광고를 노출하되 균등한 기회로 노출시킨다

### 목표: 샘플 행 가져오기

- 대량의 데이터 집합에서 샘플(일부) 데이터를 가져오는 작업이 있다고 하자
    - 광고나 강조하고 싶은 뉴스 스토리와 같은 순환 컨텐츠를 표시할 때
    - 레코드의 부분집합을 조사할 때
    - 걸려오는 전화를 가용한 오퍼레이터에 할당할 때
    - 테스트 데이터를 생성할 때
- 전체 데이터 집합을 어플리케이션으로 가져와 샘플을 고르는 것보다는 데이터베이스에 샘플을 요청하는 것이 낫다
- 목표 : 임의의 샘플 데이터만 리턴하는 효율적인 SQL 쿼리 작성하기

### 안티패턴: 데이터를 임의로 정렬하기

- 쿼리에서 임의의 행을 고르는 가장 흔한 SQL 기법 : 임의 정렬 후 첫 행 고르기
    
    ```sql
    SELECT * FROM Bugs ORDER BY RAND() LIMIT 1;
    ```
    
- 일반적인 정렬에서는, 컬럼의 값을 비교해서 어떤 행이 큰 값을 가졌는지에 따라 순서를 매긴다
    - 이 방식은, 여러번 실행해도 같은 결과를 만든다
    - 인덱스도 활용할 수 있다
    - 인덱스는 본질적으로 특정 컬럼 값으로 미리 정렬한 집합이기 때문이다
- 비결정적 정렬의 단점
    1. 인덱스를 활용할 수 없다
        - 랜덤이 될 때의 요점 : SELECT할 때마다 다르고 예측할 수 없다
        - 인덱스를 사용하지 못하면 데이터베이스가 쿼리 결과 집합을 직접 정렬해야 한다
        - 정렬해야 할 데이터가 많으면, 쿼리 결과 전체를 임시 테이블에 넣고 물리적으로 행을 교체해가며 정렬해야 한다
        - 데이터가 커질수록 인덱스의 도음을 받는 정렬보다 훨씬 느려진다
    2. 전체 데이터 집합을 정렬하는 작업을 수행하나, 작업 결과의 대부분은 낭비다
        - 예 : 추출하려했던 n개의 데이터를 제외한 나머지를 버린다

### 안티패턴 인식 방법

- “SQL에서 임의의 행을 리턴하는 건 정말 느려”
- “어플리케이션에서 사용할 메모리를 어떻게 늘릴 수 있지? 모든 행을 가져와서 그 중 임의로 한 개를 선택해야 해”
- “어떤 항목이 다른 것보다 좀 더 자주 나오는 것 같아 보이지 않니? 랜덤이 별로 랜덤같지 않은데?”

### 안티패턴 사용이 합당한 경우

- 데이터 집합이 적을 때는 이 비효율성을 참을 수 있다
- 즉, 크기가 적당하고 데이터가 늘어날 일이 거의 없는 경우이다
- 예 : 미국의 50개 주 중에서 임의로 하나를 선택하는 경우

### 해법: 테이블 전체 정렬 피하기

- 최적화할 수 없는 쿼리를 최적화하려고 하기보다는, 새로운 접근방법을 생각해보자
- **1과 MAX 사이에서 임의의 키 값 고르기**
    - 1과 PK 최댓값 사이에서 임의의 값을 선택한다
        
        ```sql
        SELECT g1.*
        FROM bugs AS b1
        JOIN (SELECT CEIL(RAND() * (SELECT MAX(bug_id) FROM bugs)) AS rand_id )) AS b2
        ON (b1.bug_id = b2.rand_id);
        ```
        
    - 하지만, 이 방법은 1부터 PK값까지 연속적으로 존재한다고 가정한다
    - 키가 1과 최댓값 사이의 모든 값을 사용하는 경우에 이 방법을 사용할 수 있다
- **다음으로 큰 키 값 고르기**
    - 첫 번째 방법에서, 1과 MAX 사이에 빈 값이 있는 경우 이 방법을 사용할 수 있다
        
        ```sql
        SELECT g1.*
        FROM bugs AS b1
        JOIN (SELECT CEIL(RAND() * (SELECT MAX(bug_id) FROM bugs)) AS bug_id )) AS b2
        WHERE b1.bug_id>=b2.bug_id
        ORDER BY b1.bug_id
        LIMIT 1;
        ```
        
    - 하지만, 이 방법은 빈틈 바로 앞에 있는 키 값이 더 자주 선택된다
    - 즉, 랜덤값 자체는 균일해도, 선택되는 bug_id 값 자체는 균일하지 않을 수 있다
- **모든 키 값의 목록을 구한 다음, 임의로 하나 고르기**
    - 결과 집합 PK 값 하나를 고르는 어플리케이션 코드를 작성한다
    - 데이터베이스에서 전체 행을 조회하고, 그 중 하나를 선택하여 데이터베이스에서 조회한다
    - 이 방법은, 테이블 정렬을 피하고, 각 키값이 거의 같은 확률로 선택된다
    - 하지만, 전체 PK를 조회하는 과정에서 비용이 발생한다
        - 메모리 자원 이슈
            - 모든 PK를 조회할 때, 리스트 크기가 엄청나게 클 수 있는데 어플리케이션 메모리 자원을 넘어서면 에러가 발생할 수 있다
        - 쿼리를 두 번해야 한다
            - 한 번은 PK 목록을 조회하기 위해, 또 한번은 임의의 행을 가져오기 위해
            - 쿼리가 지나치게 복잡하고 비용이 많이 든다면, 이게 문제가 될 수 있다
- **오프셋을 이용해 임의로 고르기**
    - 데이터 집합에서 행의 개수를 세고 0과 행 개수 사이의 임의의 수를 골라 데이터 집합을 쿼리할 때 이 수를 오프셋으로 사용한다
        
        ```sql
        SELECT ROUND(RAND() * SELECT COUNT(*) FROM bugs));
        ```
        
        ```sql
        SELECT *
        FROM bugs
        LIMIT 1
        OFFSET 오프셋;
        ```
        
    - 이 방법은 표준 SQL이 아닌 LIMIT 절에 의존하고 있다
    - LIMIT은 MySQL, PostgreSQL 등에 있다
    - 물론, 다른 DB에서는 다른 대안을 사용할 수 있다
- **벤더 종속적인 방법**
    - 데이터베이스 제품에 이런 종류의 작업을 위한 각자의 방법이 있을 수 있다
    - Microsoft SQL Server 2005에는 TABLESAMPLE 절이 있다
        
        ```sql
        SELECT * FROM bugs TABLESAMPLE (1 ROWS);
        ```
        
    - Oracle은 SAMPLE 절을 사용한다
        
        ```sql
        SELECT *
        FROM (SELECT * FROM bugs SAMPLE (1) ORDER BY dbms_random.value)
        WHERE ROWNUM=1;
        ```
        
    - 데이터베이스 제품에서만 지원하는 고유 기능을 사용해볼 수 있다

> ***어떤 쿼리는 최적화할 수 없다.**
**이 경우에는 다른 접근방법을 취해야 한다.***
>