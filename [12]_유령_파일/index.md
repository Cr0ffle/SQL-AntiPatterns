# [12] 유령 파일

### 문제 상황

---

1. 데이터베이스 서버에 큰 문제가 생겨서 복구할 수 없는 수준이 되었다
2. 받아둔 백업으로 새로운 서버를 배치하고 데이터베이스를 복원했다
3. 하지만, 이미지가 누락되어 표시되지 않는다
4. 왜냐하면, 이미지는 데이터베이스 밖의 파일 시스템에 일반 파일로 저장하고, 경로만 저장했기 때문이다

### 목표: 이미지 또는 벌크 이미지 저장

---

- 어플리케이션에서 이미지나 다른 미디어를 사용하기도 한다
- 데이터베이스에서 이런 엔티티를 쿼리할 때 관련된 이미지나 미디어를 함께 얻을 수 있어야 한다

### 안티패턴: 파일을 사용해야 한다고 가정한다

---

- 이미지에 대한 데이터 타입 선정은 조금 논란이 있다
    - 이미지는 테이블의 속성이다
        
        ```sql
        CREATE TABLE screenshots (
        	bug_id           BIGINT UNSIGNED NOT NULL,
        	image_id         BIGINT UNSIGNED NOT NULL,
        	**screenshot_image BLOB,**
        	caption          VARCHAR(100),
        	PRIMARY KEY      (bug_id, image_id),
        	FOREIGN KEY      (bug_id) REFERENCES bugs(bug_id)
        )
        ```
        
    - 이미지를 파일 시스템에 파일로 저장하고 파일에 대한 경로만 데이터베이스에 저장한다
        
        ```sql
        CREATE TABLE screenshots (
        	bug_id          BIGINT UNSIGNED NOT NULL,
        	image_id        BIGINT UNSIGNED NOT NULL,
        	**screenshot_path VARCHAR(100),**
        	caption         VARCHAR(100),
        	PRIMARY KEY     (bug_id, image_id),
        	FOREIGN KEY     (bug_id) REFERENCES bugs(bug_id)
        )
        ```
        
- 두 방법 모두 나름의 이유가 있지만, 파일을 별도로 저장하는 방식은 몇가지 중대한 위험이 있다
    - DELETE 문제
        - garbage collection과 관련이 있다
        - 이미지가 데이터베이스 밖에 저장되어있고, 그 경로를 포함하는 행을 삭제할 때, 해당 행이 가리키는 경로의 파일을 자동으로 삭제하는 방법이 없다
        - 어플리케이션에서 행을 삭제할 때 이미지 파일도 함께 삭제하도록 설계해야 한다
        - 그렇지 않으면 고아가 된 이미지 파일이 계속 쌓일 것이다
    - 트랜잭션 문제
        - 보통은 데이터를 업데이트하거나 삭제할 때, `COMMIT`으로 트랜잭션을 끝내기 전까지는, 변경 사항이 다른 클라이언트에 보이지 않는다
        - 파일의 내용을 변경하면, 트랜잭션이 커밋되지 않은 상태라도 다른 클라이언트에서 파일의 변경된 내용을 즉시 보게 된다
        - 또한 하지만 파일을 삭제하면, 그 즉시 다른 클라이언트에서도 접근하지 못하게 된다
    - ROLLBACK 문제
        - 에러가 발생한 경우나 로직이 변경사항을 취소해야 하는 경우, 데이터베이스에서는 롤백을 수행한다
        - 데이터베이스 행은 복원되지만, 이미지 파일은 그렇지 않다
    - 백업 문제
        - 대부분의 데이터베이스 제품은 사용중인 데이터베이스 백업을 돕기 위한 클라이언트 도구를 제공한다 (예 : MySQL의 mysqldump)
        - 백업 도구는 테이블에 저장된 파일 경로를 어떻게 포함시켜야 하는지 모른다
        - 따라서, 데이터베이스 백업 도구를 사용하고, 그 다음 외부 이미지를 백업하기 위해 파일 시스템 백업 도구를 사용해야 한다
        - 하지만, 백업에 외부 파일을 포함시켰다 하더라도, 파일을 복사한 것과 데이터베이스 백업이 잘 동기화됐는지는 단정할 수 없다
        - 왜냐하면, 데이터베이스 백업을 시작한 후에, 어플리케이션에서 이미지 파일을 추가할수도, 변경할 수도 있기 때문이다
            - 백업 도중 다른 클라이언트가 동시에 데이터베이스에 변경을 가하고 있으면, 백업에 일부분만 변경된 내용이 포함되거나 잠재적으로 참조 정합성이 깨지거나, 심지어는 백업 자체가 깨져 복구에 사용할 수 없게 될 수도 있다
    - SQL 접근 권한 문제
        - 외부 파일은 GRANT나 REVOKE 등으로 접근 권한을 우회한다
        - 하지만, SQL 접근권한 제어로 외부 파일의 접근을 통제할 수는 없다
    - SQL 데이터 타입 문제
        - 저장 경로는 문자열일 뿐이다
        - 따라서, 문자열이 유효한 경로인지 검증할 수 없다
        - 파일 이름을 변경하거나 삭제, 또는 디렉토리를 이동한다 하더라도 데이터베이스는 이 문자열을 자동으로 업데이트하지 않는다
        - 결국, 이 문자열을 경로로 다루는 로직은 어떤 것이든 어플리케이션 코드에 의존할 수 밖에 없다

### 안티패턴 인식 방법

---

- 프로젝트에서 아래 질문에 대해 생각해보지 않았다면, 이 안티패턴에 대해 유죄다
    - 데이터 백업과 복원 절차는 어떻게 되는가?
    백업을 어떻게 검증할 수 있는가?
    백업을 만든 서버 이외의 다른 서버에서 데이터 복원 테스트를 해본 적이 있는가?
    - 이미지가 계속 쌓이는가?
    더 이상 필요하지 않으면 시스템에서 삭제되는가?
    이미지를 삭제하는 절차는 어떻게 되는가? 자동화인가? 수작업인가?
    - 어떤 사용자가 이미지를 볼 수 있는 권한이 있는가?
    권한을 어떻게 확인하는가?
    권한이 없는 이미지를 요청하면 사용자가 뭘 보게 되는가?
    - 이미지에 대한 변경을 취소할 수 있는가?
    어플리케이션이 이전 상태의 이미지로 복원해야 하는가?
- 모든 어플리케이션에서 이미지 파일에 대한 정확한 트랜잭션 관리나 SQL 접근 제어가 필요한 것은 아니다
- 하지만, 위의 질문에 답이 명확하지 않는다면, 프로젝트에서 외부 파일 사용을 부주의하게 설계했음을 나타낸다

### 안티패턴 사용이 합당한 경우

---

- 이미지나 다른 대형 객체를 데이터베이스 외부에 파일로 저장하는 것이 좋은 이유도 있다
    - 이미지가 없다면 데이터베이스가 훨씬 가벼워진다
    - 이미지를 제외하면 데이터베이스 백업이 빨라지고 결과도 작다
    - 이미지가 데이터베이스 외부의 파일로 되어있으면, 일반적인 이미지 미리보기나 편집이 쉽다
- 이미지를 파일로 저장할 때의 이런 장점이 상대적으로 더 중요하다면, 이미지를 데이터베이스 밖에 저장하는 것이 올바른 결정일 수도 있다
- 이미지를 사용하는 어플리케이션이라면 안티패턴 절에서 설명한 문제가 영향을 미치는지 아닌지를 알아야 한다
- ‘이미지를 외부 파일로 저장하는 것이 항상 제일 좋은 방법이다!’라는 통념을 가진 프로그래머들의 말을 듣기보다는, 제대로 알고 결정을 해야 한다

### 해법: 필요한 경우에는 BLOB 데이터 타입을 사용하라

---

- 앞의 안티패턴 절에서 설명한 이슈에 하나라도 해당이 된다면, 이미지를 외부 파일이 아닌 데이터베이스 내부에 저장하는 것을 고려해야 한다
- BLOB 데이터 타입은 바이너리 데이터 저장을 할 수 있다
- 이미지를 BLOB 컬럼에 저장하면, 모든 이슈가 해결된다
    - 이미지 데이터가 데이터베이스에 저장된다
    - 행을 삭제하면 이미지도 자동으로 삭제된다
    - 커밋 전까지는, 이미지 변경이 다른 클라이언트에 보이지 않는다
    - 트랜잭션을 롤백하면 이미지도 이전 상태로 복원된다
    - 행을 업데이트할 때, 해당 행에 잠금이 설정되어 다른 클라이언트는 동일한 이미지를 동시에 업데이트할 수 없다
    - 데이터베이스 백업에 모든 이미지가 포함된다
    - SQL 권한은 행 뿐 아니라, 이미지에 대한 접근도 제어한다

> ***데이터베이스 밖의 리소스는 데이터베이스가 관리하지 않는다***
>